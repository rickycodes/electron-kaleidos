'use strict'

const qs = require('qs')
/*global THREE*/

module.exports = function (config) {
  if (!config.scene) {
    return
  }
  var three, canvas, context, camera, scene, renderer, texture
  var mouse = new THREE.Vector2()
  var amout = (config) ? config.amount : 400
  var size = (config) ? config.size : 20
  var ease = (config) ? config.ease : 0.1
  var interactive = (config) ? config.interactive : false
  // var theta = 0
  var halfx = window.innerWidth / 2
  var halfy = window.innerHeight / 2

  init()
  animate()

  function init () {
    canvas = document.createElement('canvas')
    three = document.createElement('div')
    context = canvas.getContext('2d')

    canvas.setAttribute('class', 'sample')
    canvas.setAttribute('width', '400')
    canvas.setAttribute('height', '400')
    canvas.style.display = 'none'

    three.setAttribute('class', 'three')

    context.drawImage(qs('.kaleidoscope'), -600, -600)

    qs('body').appendChild(canvas)
    qs('body').appendChild(three)

    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000)
    scene = new THREE.Scene()

    var light = new THREE.DirectionalLight(0xffffff, 1)
    light.position.set(1, 1, 1).normalize()
    scene.add(light)

    var geometry = new THREE.BoxGeometry(size, size, size)
    texture = new THREE.Texture(qs('.sample'))
    texture.minFilter = THREE.NearestFilter
    var material = new THREE.MeshBasicMaterial({ map: texture })

    for (var i = 0; i < amout; i++) {
      var object = new THREE.Mesh(geometry, material)

      object.position.x = Math.random() * 800 - 400
      object.position.y = Math.random() * 800 - 400
      object.position.z = Math.random() * 800 - 400

      object.rotation.x = Math.random() * 2 * Math.PI
      object.rotation.y = Math.random() * 2 * Math.PI
      object.rotation.z = Math.random() * 2 * Math.PI

      object.scale.x = object.scale.y = object.scale.z = Math.random() * 2.2

      scene.add(object)
    }

    renderer = new THREE.WebGLRenderer({alpha: true})
    renderer.setPixelRatio(window.devicePixelRatio)
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.sortObjects = false
    qs('.three').appendChild(renderer.domElement)
    if (interactive) {
      document.addEventListener('mousemove', onDocumentMouseMove, false)
    }
    window.addEventListener('resize', onWindowResize, false)
  }

  function onWindowResize () {
    camera.aspect = window.innerWidth / window.innerHeight
    camera.updateProjectionMatrix()
    renderer.setSize(window.innerWidth, window.innerHeight)
  }

  function onDocumentMouseMove (e) {
    e.preventDefault()
    mouse.x = e.clientX - halfx
    mouse.y = e.clientY - halfy
  }

  function animate () {
    requestAnimationFrame(animate)
    render()
  }

  function moveCamera () {
    camera.position.x += (mouse.x - camera.position.x) * ease
    camera.position.y += (-mouse.y - camera.position.y) * ease
    camera.position.z += (-mouse.y - camera.position.y) * ease
    return camera.lookAt(scene.position)
  }

  function render () {
    // theta += 0.1
    // camera.position.x = radius * Math.sin( THREE.Math.degToRad( theta ) )
    // camera.position.y = radius * Math.sin( THREE.Math.degToRad( theta ) )
    // camera.position.z = radius * Math.cos( THREE.Math.degToRad( theta ) )
    // camera.lookAt( scene.position )

    var time = new Date().getTime() * 0.0006
    mouse.x = Math.sin(time) * 150 + 400
    mouse.y = Math.cos(time * 0.9) * 150 + 400

    scene.children.forEach(function (child) {
      child.rotation.x += (mouse.x - camera.position.x) * 0.001
      child.rotation.y += (-mouse.y - camera.position.y) * 0.002
      child.rotation.z += (-mouse.y - camera.position.y) * 0.003
    })
    camera.updateMatrixWorld()
    moveCamera()
    texture.needsUpdate = true
    context.drawImage(qs('.kaleidoscope'), -600, -600)
    renderer.render(scene, camera)
  }
}
