/*global THREE requestAnimationFrame*/
'use strict'

const qs = require('qs')
const sa = require('spectrum-analyzer')

module.exports = function (config) {
  if (!config.scene) {
    return
  }
  var x, y, three, canvas, context, camera, scene, group, renderer, texture
  var mouse = new THREE.Vector2()
  var amout = (config) ? config.amount : 400
  var size = (config) ? config.size : 20
  var ease = (config) ? config.ease : 0.1
  var interactive = (config) ? config.interactive : false
  // var theta = 0
  var halfx = window.innerWidth / 2
  var halfy = window.innerHeight / 2

  var audio
  var analyzer

  init()
  animate()

  function initAudio() {
    audio = document.createElement('audio')
    audio.crossOrigin = 'anonymous'
    audio.src = 'https://raw.githubusercontent.com/rickycodes/tones/master/the-knife.mp3'

    analyzer = new sa(32 * 0.5, 0.80)
    analyzer.setSource(audio)

    audio.currentTime = 0
    audio.play()
  }

  function init () {
    initAudio()
    canvas = document.createElement('canvas')
    three = document.createElement('div')
    context = canvas.getContext('2d')

    canvas.setAttribute('class', 'sample')
    canvas.setAttribute('width', '400')
    canvas.setAttribute('height', '400')
    canvas.style.display = 'none'

    three.setAttribute('class', 'three')

    context.drawImage(qs('.kaleidoscope'), -600, -600)

    qs('body').appendChild(canvas)
    qs('body').appendChild(three)

    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000)
    group = new THREE.Object3D()
    scene = new THREE.Scene()

    var light = new THREE.DirectionalLight(0xffffff, 1)
    light.position.set(1, 1, 1).normalize()
    scene.add(light)

    var geometry = new THREE.BoxGeometry(size, size, size)
    texture = new THREE.Texture(qs('.sample'))
    texture.minFilter = THREE.NearestFilter
    var material = new THREE.MeshBasicMaterial({ map: texture })

    for (var i = 0; i < amout; i++) {
      var object = new THREE.Mesh(geometry, material)

      object.position.x = Math.random() * 800 - 400
      object.position.y = Math.random() * 800 - 400
      object.position.z = Math.random() * 800 - 400

      object.rotation.x = Math.random() * 2 * Math.PI
      object.rotation.y = Math.random() * 2 * Math.PI
      object.rotation.z = Math.random() * 2 * Math.PI

      object.scale.x = object.scale.y = object.scale.z = Math.random() * 2.2

      group.add(object)
    }

    scene.add(group)

    renderer = new THREE.WebGLRenderer({alpha: true})
    renderer.setPixelRatio(window.devicePixelRatio)
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.sortObjects = false
    qs('.three').appendChild(renderer.domElement)
    if (interactive) {
      document.addEventListener('mousemove', onDocumentMouseMove, false)
    }
    window.addEventListener('resize', onWindowResize, false)
  }

  function onWindowResize () {
    camera.aspect = window.innerWidth / window.innerHeight
    camera.updateProjectionMatrix()
    renderer.setSize(window.innerWidth, window.innerHeight)
  }

  function onDocumentMouseMove (e) {
    e.preventDefault()
    mouse.x = e.clientX - halfx
    mouse.y = e.clientY - halfy
  }

  function animate () {
    requestAnimationFrame(animate)
    render()
  }

  function moveCamera () {
    camera.position.x += (x - camera.position.x) * ease
    camera.position.y += (-y - camera.position.y) * ease
    camera.position.z += (-y - camera.position.y) * ease
    return camera.lookAt(scene.position)
  }

  function render () {
    analyzer.updateSample()
    var data = analyzer.frequencyByteData
    // console.log(data)
    var time = new Date().getTime() * 0.0006
    x = Math.sin(time) * 150 + 400
    y = Math.cos(time * 0.9) * 150 + 400
    group.rotation.x += 0.001
    group.rotation.y += 0.002
    group.rotation.z += 0.003
    group.children.forEach(function (child) {
      child.rotation.x += 0.01
      child.rotation.y += 0.02
      child.rotation.z += 0.03
    })
    camera.updateMatrixWorld()
    moveCamera()
    texture.needsUpdate = true
    context.drawImage(qs('.kaleidoscope'), -600, -600)
    renderer.render(scene, camera)
  }
}
