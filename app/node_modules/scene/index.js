'use strict'

const qs = require('qs')
/*global THREE*/

module.exports = function(config) {
  var three, canvas, context, camera, scene, renderer, texture
  var mouse = new THREE.Vector2()
  var amout = (config) ? config.amount : 400
  var size = (config) ? config.size : 20
  var ease = (config) ? config.ease : 0.1
  var interactive = (config) ? config.interactive : false
  // var theta = 0
  var halfx = window.innerWidth / 2
  var halfy = window.innerHeight / 2

  init()
  animate()

  function init() {

    canvas = document.createElement('canvas')
    three = document.createElement('div')
    context = canvas.getContext('2d')

    canvas.setAttribute('class','sample')
    canvas.setAttribute('width','400')
    canvas.setAttribute('height','400')
    canvas.style.display = 'none'

    three.setAttribute('class','three')

    context.drawImage(qs('.kaleidoscope'),-600,-600)

    qs('body').appendChild(canvas)
    qs('body').appendChild(three)

    camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 )
    scene = new THREE.Scene()

    var light = new THREE.DirectionalLight( 0xffffff, 1 )
    light.position.set( 1, 1, 1 ).normalize()
    scene.add( light )

    var geometry = new THREE.BoxGeometry( size, size, size )
    texture = new THREE.Texture(qs('.sample'))
    texture.minFilter = THREE.NearestFilter
    var material = new THREE.MeshBasicMaterial( { map: texture } )

    for ( var i = 0; i < amout; i ++ ) {

      var object = new THREE.Mesh( geometry, material )

      object.position.x = Math.random() * 800 - 400
      object.position.y = Math.random() * 800 - 400
      object.position.z = Math.random() * 800 - 400

      object.rotation.x = Math.random() * 2 * Math.PI
      object.rotation.y = Math.random() * 2 * Math.PI
      object.rotation.z = Math.random() * 2 * Math.PI

      // object.scale.x = Math.random() + 0.5
      // object.scale.y = Math.random() + 0.5
      // object.scale.z = Math.random() + 0.5

      scene.add( object )
    }

    renderer = new THREE.WebGLRenderer({alpha: true})
    renderer.setPixelRatio( window.devicePixelRatio )
    renderer.setSize( window.innerWidth, window.innerHeight )
    renderer.sortObjects = false
    qs('.three').appendChild(renderer.domElement)
    if(interactive) document.addEventListener( 'mousemove', onDocumentMouseMove, false )
    window.addEventListener( 'resize', onWindowResize, false )
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight
    camera.updateProjectionMatrix()
    renderer.setSize( window.innerWidth, window.innerHeight )
  }

  function onDocumentMouseMove(e) {
    event.preventDefault()
    mouse.x = e.clientX - halfx
    mouse.y = e.clientY - halfy
    // mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1
    // mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1
    moveCamera()
  }

  function animate() {
    requestAnimationFrame( animate )
    render()
  }

  function moveCamera() {
    camera.position.x += (mouse.x - camera.position.x) * ease
    camera.position.y += (-mouse.y - camera.position.y) * ease
    camera.position.z += (-mouse.y - camera.position.y) * ease
    return camera.lookAt(scene.position)
  }

  function render() {
    // theta += 0.1
    // camera.position.x = radius * Math.sin( THREE.Math.degToRad( theta ) )
    // camera.position.y = radius * Math.sin( THREE.Math.degToRad( theta ) )
    // camera.position.z = radius * Math.cos( THREE.Math.degToRad( theta ) )
    // camera.lookAt( scene.position )

    camera.updateMatrixWorld()
    texture.needsUpdate = true
    context.drawImage(qs('.kaleidoscope'),-600,-600)
    renderer.render( scene, camera )
  }
}
